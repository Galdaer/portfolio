{
  "id": "20859b785793453f97588b12f3ecaf43",
  "name": "Medical Transcription Action",
  "meta": {
    "description": "Medical Transcription Action",
    "manifest": {},
    "type": "action"
  },
  "content": "\"\"\"\nMedical Transcription Action for Open WebUI (Standalone Version)\nProvides a simple button interface for live medical transcription with automatic SOAP note generation.\nThis standalone version works without external dependencies.\n\"\"\"\n\nimport asyncio\nimport json\nimport logging\nimport os\nfrom datetime import datetime\nfrom typing import Any, Optional\n\nfrom pydantic import BaseModel, Field\n\n\n\nimport os\nfrom typing import Dict, Any\n\n# Fallback configuration when external config files aren't available\nclass FallbackConfig:\n    \"\"\"Fallback configuration using environment variables.\"\"\"\n    \n    def __init__(self):\n        # Transcription defaults\n        self.websocket_base_url = os.getenv('HEALTHCARE_WEBSOCKET_URL', 'ws://localhost:8000')\n        self.rest_api_url = os.getenv('HEALTHCARE_REST_URL', 'http://localhost:8000')\n        self.timeout_seconds = int(os.getenv('TRANSCRIPTION_TIMEOUT', '300'))\n        self.chunk_interval = int(os.getenv('CHUNK_INTERVAL', '2'))\n        self.confidence_threshold = float(os.getenv('CONFIDENCE_THRESHOLD', '0.85'))\n        \n        # UI defaults\n        self.developer_mode = os.getenv('DEVELOPER_MODE', 'true').lower() == 'true'\n        self.debug_logging = os.getenv('DEBUG_LOGGING', 'false').lower() == 'true'\n        self.mock_transcription = os.getenv('MOCK_TRANSCRIPTION', 'false').lower() == 'true'\n        self.show_disclaimer = os.getenv('SHOW_MEDICAL_DISCLAIMER', 'true').lower() == 'true'\n        self.phi_protection = os.getenv('PHI_PROTECTION_ENABLED', 'true').lower() == 'true'\n\n# Create fallback configuration instances\ntry:\n    # Try to import original configs if available\n    from config.transcription_config_loader import TRANSCRIPTION_CONFIG\n    from config.ui_config_loader import UI_CONFIG\nexcept ImportError:\n    # Use fallback configuration\n    fallback = FallbackConfig()\n    \n    # Mock config objects to match expected structure\n    class MockTranscriptionConfig:\n        def __init__(self):\n            self.websocket = type('obj', (object,), {'base_url': fallback.websocket_base_url})\n            self.session = type('obj', (object,), {\n                'default_timeout_seconds': fallback.timeout_seconds,\n                'audio_chunk_interval_seconds': fallback.chunk_interval\n            })\n            self.quality = type('obj', (object,), {\n                'default_confidence_threshold': fallback.confidence_threshold,\n                'high_confidence_threshold': fallback.confidence_threshold + 0.05\n            })\n    \n    class MockUIConfig:\n        def __init__(self):\n            self.api_integration = type('obj', (object,), {\n                'websocket_url': fallback.websocket_base_url,\n                'rest_api_url': fallback.rest_api_url\n            })\n            self.developer = type('obj', (object,), {\n                'mode_enabled': fallback.developer_mode,\n                'debug_logging': fallback.debug_logging,\n                'mock_transcription': fallback.mock_transcription,\n                'test_users': [\"admin\", \"justin\", \"jeff\"],\n                'default_test_user': \"admin\"\n            })\n            self.compliance = type('obj', (object,), {\n                'show_medical_disclaimer': fallback.show_disclaimer,\n                'phi_protection_enabled': fallback.phi_protection,\n                'disclaimer_text': \"This system provides administrative support only, not medical advice.\"\n            })\n            self.session = type('obj', (object,), {\n                'timeout_seconds': fallback.timeout_seconds,\n                'chunk_interval_seconds': fallback.chunk_interval,\n                'auto_soap_generation': True\n            })\n            self.user_experience = type('obj', (object,), {\n                'show_real_time_transcription': True\n            })\n    \n    TRANSCRIPTION_CONFIG = MockTranscriptionConfig()\n    UI_CONFIG = MockUIConfig()\n\n\nclass Action:\n    \"\"\"\n    Medical Transcription Action\n\n    Adds a \"🎙️ Start Medical Transcription\" button to Open WebUI chat interface.\n    When clicked, starts live transcription session and generates SOAP notes automatically.\n    This standalone version uses environment variables and fallback configurations.\n    \"\"\"\n\n    class Valves(BaseModel):\n        \"\"\"Dynamic Configuration for Medical Transcription Action - editable via Open WebUI\"\"\"\n\n        # === Healthcare API Configuration ===\n        HEALTHCARE_API_URL: str = Field(\n            default=os.getenv('HEALTHCARE_WEBSOCKET_URL', 'ws://localhost:8000'),\n            description=\"WebSocket URL for healthcare API connection\",\n        )\n        HEALTHCARE_REST_URL: str = Field(\n            default=os.getenv('HEALTHCARE_REST_URL', 'http://localhost:8000'),\n            description=\"REST API URL for healthcare services\",\n        )\n\n        # === Developer Configuration ===\n        DEVELOPER_MODE: bool = Field(\n            default=os.getenv('DEVELOPER_MODE', 'true').lower() == 'true',\n            description=\"Enable developer mode with additional logging and test features\",\n        )\n        DEVELOPER_USERS: list = Field(\n            default=os.getenv('DEVELOPER_USERS', 'admin,justin,jeff').split(','),\n            description=\"List of approved developer users for testing\",\n        )\n        DEFAULT_TEST_USER: str = Field(\n            default=os.getenv('DEFAULT_TEST_USER', 'admin'),\n            description=\"Default user for testing when user detection fails\",\n        )\n        DEBUG_LOGGING: bool = Field(\n            default=os.getenv('DEBUG_LOGGING', 'false').lower() == 'true',\n            description=\"Enable detailed debug logging for troubleshooting\",\n        )\n        MOCK_TRANSCRIPTION: bool = Field(\n            default=os.getenv('MOCK_TRANSCRIPTION', 'false').lower() == 'true',\n            description=\"Use mock transcription for testing without real audio processing\",\n        )\n\n        # === Transcription Settings ===\n        TRANSCRIPTION_TIMEOUT: int = Field(\n            default=int(os.getenv('TRANSCRIPTION_TIMEOUT', '300')),\n            ge=60,\n            le=1800,\n            description=\"Maximum transcription session duration in seconds (1-30 minutes)\",\n        )\n        CHUNK_INTERVAL: int = Field(\n            default=int(os.getenv('CHUNK_INTERVAL', '2')),\n            ge=1,\n            le=10,\n            description=\"Audio chunk interval in seconds (1-10 seconds)\",\n        )\n        AUTO_SOAP_GENERATION: bool = Field(\n            default=os.getenv('AUTO_SOAP_GENERATION', 'true').lower() == 'true',\n            description=\"Automatically generate SOAP notes from completed transcriptions\",\n        )\n\n        # === Medical Compliance ===\n        MEDICAL_DISCLAIMER: str = Field(\n            default=os.getenv('MEDICAL_DISCLAIMER_TEXT',\n                            \"⚠️ **Medical Disclaimer**: This system provides administrative support only, \"\n                            \"not medical advice. Always consult healthcare professionals for medical decisions. \"\n                            \"This tool is for documentation assistance only.\"),\n            description=\"Medical disclaimer text shown to users\",\n        )\n        SHOW_MEDICAL_DISCLAIMER: bool = Field(\n            default=os.getenv('SHOW_MEDICAL_DISCLAIMER', 'true').lower() == 'true',\n            description=\"Display medical disclaimer to users\",\n        )\n        PHI_PROTECTION_ENABLED: bool = Field(\n            default=os.getenv('PHI_PROTECTION_ENABLED', 'true').lower() == 'true',\n            description=\"Enable PHI (Protected Health Information) protection\",\n        )\n\n        # === User Experience ===\n        SHOW_REAL_TIME_TRANSCRIPTION: bool = Field(\n            default=os.getenv('SHOW_REAL_TIME_TRANSCRIPTION', 'true').lower() == 'true',\n            description=\"Show transcription results in real-time as they are processed\",\n        )\n        SHOW_STATUS_UPDATES: bool = Field(\n            default=os.getenv('SHOW_STATUS_UPDATES', 'true').lower() == 'true',\n            description=\"Display status updates during transcription process\",\n        )\n        ALLOW_SESSION_HISTORY: bool = Field(\n            default=os.getenv('ALLOW_SESSION_HISTORY', 'true').lower() == 'true',\n            description=\"Allow users to view previous transcription sessions\",\n        )\n\n        # === Advanced Settings ===\n        CONNECTION_RETRY_ATTEMPTS: int = Field(\n            default=int(os.getenv('CONNECTION_RETRY_ATTEMPTS', '3')),\n            ge=1,\n            le=10,\n            description=\"Number of connection retry attempts (1-10)\",\n        )\n        RETRY_DELAY_SECONDS: int = Field(\n            default=int(os.getenv('RETRY_DELAY_SECONDS', '5')),\n            ge=1,\n            le=30,\n            description=\"Delay between retry attempts in seconds (1-30)\",\n        )\n        MAX_TRANSCRIPTION_LENGTH: int = Field(\n            default=int(os.getenv('MAX_TRANSCRIPTION_LENGTH', '10000')),\n            ge=1000,\n            le=50000,\n            description=\"Maximum transcription length in characters (1000-50000)\",\n        )\n\n    def __init__(self):\n        self.valves = self.Valves()\n        self._setup_logging()\n\n    def _setup_logging(self):\n        \"\"\"Setup logging configuration.\"\"\"\n        log_level = logging.DEBUG if self.valves.DEBUG_LOGGING else logging.INFO\n        logging.basicConfig(\n            level=log_level,\n            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n        )\n        self.logger = logging.getLogger(__name__)\n\n    def _is_developer_user(self, user_id: str) -> bool:\n        \"\"\"Check if user is in developer list.\"\"\"\n        return user_id in self.valves.DEVELOPER_USERS\n\n    def _get_mock_transcription_data(self) -> dict:\n        \"\"\"Generate mock transcription data for testing.\"\"\"\n        return {\n            \"session_id\": f\"mock_session_{datetime.now().strftime('%Y%m%d_%H%M%S')}\",\n            \"status\": \"completed\",\n            \"transcription\": {\n                \"text\": \"Patient presents with chief complaint of headache lasting 3 days. \"\n                       \"Pain is described as throbbing, located in temporal region. \"\n                       \"Associated with mild nausea. No fever or visual disturbances. \"\n                       \"Patient has history of migraines. Current medications include \"\n                       \"ibuprofen as needed. Physical examination shows blood pressure \"\n                       \"120/80, pulse 72, temperature 98.6 F. Neurological exam normal.\",\n                \"confidence_score\": 0.92,\n                \"duration_seconds\": 180,\n                \"word_count\": 67\n            },\n            \"soap_note\": {\n                \"subjective\": \"Patient reports headache lasting 3 days, throbbing in nature, \"\n                             \"located in temporal region, associated with mild nausea. \"\n                             \"History of migraines. Takes ibuprofen as needed.\",\n                \"objective\": \"Vital signs: BP 120/80, HR 72, T 98.6°F. \"\n                            \"Neurological examination within normal limits.\",\n                \"assessment\": \"Likely migraine headache, consistent with patient's history.\",\n                \"plan\": \"Continue current ibuprofen regimen. Consider preventive therapy \"\n                       \"if frequency increases. Follow up if symptoms worsen or persist.\"\n            },\n            \"metadata\": {\n                \"phi_detected\": False,\n                \"quality_flags\": [],\n                \"processing_time_ms\": 1500\n            }\n        }\n\n    async def _simulate_transcription_session(self, __event_emitter__=None):\n        \"\"\"Simulate a transcription session for testing.\"\"\"\n        if __event_emitter__:\n            await __event_emitter__({\n                \"type\": \"status\",\n                \"data\": {\"description\": \"🎭 Starting mock transcription session...\"}\n            })\n            await asyncio.sleep(1)\n\n            await __event_emitter__({\n                \"type\": \"status\", \n                \"data\": {\"description\": \"🎤 Mock audio processing started\"}\n            })\n            await asyncio.sleep(2)\n\n            if self.valves.SHOW_REAL_TIME_TRANSCRIPTION:\n                partial_texts = [\n                    \"Patient presents with...\",\n                    \"Patient presents with chief complaint of headache...\",\n                    \"Patient presents with chief complaint of headache lasting 3 days...\"\n                ]\n                \n                for text in partial_texts:\n                    await __event_emitter__({\n                        \"type\": \"message\",\n                        \"data\": {\"content\": f\"📝 **Transcribing**: {text}\"}\n                    })\n                    await asyncio.sleep(1.5)\n\n            await __event_emitter__({\n                \"type\": \"status\",\n                \"data\": {\"description\": \"🧠 Generating SOAP note from transcription...\"}\n            })\n            await asyncio.sleep(2)\n\n        return self._get_mock_transcription_data()\n\n    def _format_transcription_response(self, transcription_data: dict) -> str:\n        \"\"\"Format transcription data into a user-friendly response.\"\"\"\n        response_parts = []\n        \n        # Add disclaimer if enabled\n        if self.valves.SHOW_MEDICAL_DISCLAIMER:\n            response_parts.append(self.valves.MEDICAL_DISCLAIMER)\n            response_parts.append(\"\\n\" + \"=\"*50 + \"\\n\")\n\n        # Add session info\n        response_parts.append(f\"## 🎙️ Medical Transcription Complete\")\n        response_parts.append(f\"**Session ID**: {transcription_data.get('session_id', 'N/A')}\")\n        response_parts.append(f\"**Status**: {transcription_data.get('status', 'unknown')}\")\n        response_parts.append(f\"**Timestamp**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")\n        response_parts.append(\"\")\n\n        # Add transcription\n        transcription = transcription_data.get('transcription', {})\n        if transcription:\n            response_parts.append(\"### 📝 Transcription\")\n            response_parts.append(f\"**Text**: {transcription.get('text', 'No transcription available')}\")\n            response_parts.append(f\"**Confidence**: {transcription.get('confidence_score', 0):.2%}\")\n            response_parts.append(f\"**Duration**: {transcription.get('duration_seconds', 0)} seconds\")\n            response_parts.append(f\"**Word Count**: {transcription.get('word_count', 0)} words\")\n            response_parts.append(\"\")\n\n        # Add SOAP note if auto-generation is enabled\n        if self.valves.AUTO_SOAP_GENERATION:\n            soap_note = transcription_data.get('soap_note', {})\n            if soap_note:\n                response_parts.append(\"### 📋 Generated SOAP Note\")\n                response_parts.append(f\"**S** (Subjective): {soap_note.get('subjective', 'N/A')}\")\n                response_parts.append(f\"**O** (Objective): {soap_note.get('objective', 'N/A')}\")\n                response_parts.append(f\"**A** (Assessment): {soap_note.get('assessment', 'N/A')}\")\n                response_parts.append(f\"**P** (Plan): {soap_note.get('plan', 'N/A')}\")\n                response_parts.append(\"\")\n\n        # Add metadata\n        metadata = transcription_data.get('metadata', {})\n        if metadata:\n            response_parts.append(\"### 📊 Session Metadata\")\n            response_parts.append(f\"**PHI Detected**: {'⚠️ Yes' if metadata.get('phi_detected', False) else '✅ None detected'}\")\n            response_parts.append(f\"**Processing Time**: {metadata.get('processing_time_ms', 0)}ms\")\n            \n            quality_flags = metadata.get('quality_flags', [])\n            if quality_flags:\n                response_parts.append(f\"**Quality Flags**: {', '.join(quality_flags)}\")\n            else:\n                response_parts.append(\"**Quality**: ✅ No issues detected\")\n\n        return \"\\n\".join(response_parts)\n\n    async def action(\n        self,\n        body: dict,\n        __user__: Optional[dict] = None,\n        __event_emitter__=None,\n    ) -> Optional[dict]:\n        \"\"\"\n        Main action handler for medical transcription.\n        \n        Args:\n            body: The request body from Open WebUI\n            __user__: User information (if available)\n            __event_emitter__: Event emitter for real-time updates\n        \"\"\"\n        try:\n            user_id = __user__.get(\"email\", self.valves.DEFAULT_TEST_USER) if __user__ else self.valves.DEFAULT_TEST_USER\n            is_developer = self._is_developer_user(user_id)\n            \n            self.logger.info(f\"Medical transcription action started for user: {user_id}\")\n\n            # Show initial status\n            if __event_emitter__ and self.valves.SHOW_STATUS_UPDATES:\n                await __event_emitter__({\n                    \"type\": \"status\",\n                    \"data\": {\"description\": \"🎙️ Initializing medical transcription session...\"}\n                })\n\n            # Check if we're in mock mode or if this is a developer\n            if self.valves.MOCK_TRANSCRIPTION or (is_developer and self.valves.DEVELOPER_MODE):\n                transcription_data = await self._simulate_transcription_session(__event_emitter__)\n                response_text = self._format_transcription_response(transcription_data)\n                \n                if __event_emitter__:\n                    await __event_emitter__({\n                        \"type\": \"status\",\n                        \"data\": {\"description\": \"✅ Mock transcription completed successfully\"}\n                    })\n                \n                return {\n                    \"content\": response_text,\n                    \"session_data\": transcription_data\n                }\n            \n            else:\n                # Real transcription mode - would connect to actual service\n                if __event_emitter__:\n                    await __event_emitter__({\n                        \"type\": \"status\",\n                        \"data\": {\"description\": f\"🔌 Connecting to transcription service at {self.valves.HEALTHCARE_API_URL}\"}\n                    })\n                \n                # For now, return instructions since we can't connect to real service in standalone mode\n                instructions = f\"\"\"\n## 🎙️ Medical Transcription Service\n\n**Configuration**:\n- WebSocket URL: `{self.valves.HEALTHCARE_API_URL}`\n- REST API URL: `{self.valves.HEALTHCARE_REST_URL}`\n- Timeout: {self.valves.TRANSCRIPTION_TIMEOUT} seconds\n- Chunk Interval: {self.valves.CHUNK_INTERVAL} seconds\n\n**Status**: ⚠️ **Standalone Mode**\n\nThis function is running in standalone mode and cannot connect to the actual transcription service.\n\n**To test this function**:\n1. Enable `MOCK_TRANSCRIPTION` in the function settings (Valves)\n2. Or set `DEVELOPER_MODE` to true if you're a developer user\n\n**To use with real transcription service**:\n1. Ensure the healthcare API service is running at the configured URL\n2. Set `MOCK_TRANSCRIPTION` to false\n3. Click the transcription button again\n\n**Current Settings**:\n- Developer Mode: {'✅ Enabled' if self.valves.DEVELOPER_MODE else '❌ Disabled'}\n- Mock Transcription: {'✅ Enabled' if self.valves.MOCK_TRANSCRIPTION else '❌ Disabled'}\n- PHI Protection: {'✅ Enabled' if self.valves.PHI_PROTECTION_ENABLED else '❌ Disabled'}\n- Auto SOAP Generation: {'✅ Enabled' if self.valves.AUTO_SOAP_GENERATION else '❌ Disabled'}\n                \"\"\"\n                \n                if self.valves.SHOW_MEDICAL_DISCLAIMER:\n                    instructions = self.valves.MEDICAL_DISCLAIMER + \"\\n\\n\" + instructions\n                \n                return {\"content\": instructions}\n\n        except Exception as e:\n            error_msg = f\"Medical transcription error: {str(e)}\"\n            self.logger.error(error_msg, exc_info=True)\n            \n            if __event_emitter__:\n                await __event_emitter__({\n                    \"type\": \"status\",\n                    \"data\": {\"description\": f\"❌ Error: {error_msg}\"}\n                })\n            \n            return {\n                \"error\": error_msg,\n                \"timestamp\": datetime.now().isoformat(),\n                \"user\": user_id\n            }"
}