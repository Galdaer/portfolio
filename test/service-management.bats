#!/usr/bin/env bats

# Test service management utility functions

setup() {
    TMPDIR=$(mktemp -d)
    
    # Mock commands for testing
    mkdir -p "$TMPDIR/bin"
    
    # Mock docker command
    cat > "$TMPDIR/bin/docker" <<'EOF'
#!/bin/bash
case "$*" in
    "ps -q --filter name=test-service")
        echo "container123"
        ;;
    "ps -q --filter name=nonexistent-service")
        # Return empty (no container)
        ;;
    "stop test-service")
        echo "Stopped test-service"
        ;;
    "stop nonexistent-service")
        echo "No such container: nonexistent-service" >&2
        exit 1
        ;;
    *)
        echo "Mock docker: $*"
        ;;
esac
EOF
    chmod +x "$TMPDIR/bin/docker"
    
    # Mock systemctl command
    cat > "$TMPDIR/bin/systemctl" <<'EOF'
#!/bin/bash
case "$*" in
    "stop system-service")
        echo "Stopped system-service"
        ;;
    "stop nonexistent-system-service")
        echo "Failed to stop nonexistent-system-service: Unit not found" >&2
        exit 1
        ;;
    *)
        echo "Mock systemctl: $*"
        ;;
esac
EOF
    chmod +x "$TMPDIR/bin/systemctl"
    
    export PATH="$TMPDIR/bin:$PATH"
    
    # Mock logging functions
    log() { echo "LOG: $*"; }
    warn() { echo "WARN: $*"; }
    ok() { echo "OK: $*"; }
    export -f log warn ok
}

teardown() {
    rm -rf "$TMPDIR"
}

@test "stop_service handles container services" {
    # Source the function
    source <(sed -n '/^stop_service()/,/^}$/p' scripts/clinic-bootstrap.sh)
    
    run stop_service test-service
    [ "$status" -eq 0 ]
    # Should call ok() function which outputs the stopped message
    [[ "$output" == *"test-service stopped"* ]]
}

@test "stop_service handles non-container services via systemctl" {
    # Source the function and mock stop_wireguard for special case
    source <(sed -n '/^stop_service()/,/^}$/p' scripts/clinic-bootstrap.sh)
    stop_wireguard() { echo "Stopped WireGuard"; }
    export -f stop_wireguard
    
    run stop_service system-service
    [ "$status" -eq 0 ]
    # Should call ok() function which outputs the stopped message
    [[ "$output" == *"system-service stopped"* ]]
}

@test "stop_service handles wireguard specially" {
    source <(sed -n '/^stop_service()/,/^}$/p' scripts/clinic-bootstrap.sh)
    stop_wireguard() { echo "Special WireGuard stop"; }
    export -f stop_wireguard
    
    run stop_service wireguard
    [ "$status" -eq 0 ]
    [[ "$output" == *"Special WireGuard stop"* ]]
    [[ "$output" == *"OK: wireguard stopped"* ]]
}

@test "stop_service handles nonexistent services gracefully" {
    source <(sed -n '/^stop_service()/,/^}$/p' scripts/clinic-bootstrap.sh)
    
    # Test nonexistent container service
    run stop_service nonexistent-service
    [ "$status" -eq 0 ]  # Should not fail completely
    [[ "$output" == *"OK: nonexistent-service stopped"* ]]
}

@test "show_ports displays port configuration" {
    # Set up test environment
    declare -A CONTAINER_PORTS=(
        [service1]="8080"
        [service2]="3000"
        [service3]="5432"
    )
    export CONTAINER_PORTS
    
    # Source all required functions
    source <(sed -n '/^get_service_config_file()/,/^}$/p' scripts/clinic-bootstrap.sh)
    source <(sed -n '/^get_service_config_value()/,/^}$/p' scripts/clinic-bootstrap.sh)
    source <(sed -n '/^show_ports()/,/^}$/p' scripts/clinic-bootstrap.sh)
    
    run show_ports
    [ "$status" -eq 0 ]
    [[ "$output" == *"service1"* ]]
    [[ "$output" == *"8080"* ]]
    [[ "$output" == *"service2"* ]]
    [[ "$output" == *"3000"* ]]
    [[ "$output" == *"service3"* ]]
    [[ "$output" == *"5432"* ]]
}

@test "reset_ports restores default port configuration" {
    # Source the function and set up test data
    source <(sed -n '/^reset_ports()/,/^}$/p' scripts/clinic-bootstrap.sh)
    log() { echo "LOG: $*"; }
    export -f log
    
    # Initialize with some ports
    declare -A CONTAINER_PORTS=(
        [traefik]="8888"
        [grafana]="3001"
    )
    export CONTAINER_PORTS
    
    run reset_ports
    [ "$status" -eq 0 ]
    [[ "$output" == *"Ports reset to defaults"* ]]
    
    # Should reset to default values (this tests the hardcoded defaults in the function)
    # Note: This test validates the function executes without checking specific defaults
    # since those are autogenerated and may change
}

@test "auto_install_deps identifies missing dependencies" {
    # Source required functions and set up environment
    source <(sed -n '/^auto_install_deps()/,/^}$/p' scripts/clinic-bootstrap.sh)
    
    # Set required variables
    DRY_RUN="false"
    NON_INTERACTIVE="true" 
    FORCE_DEFAULTS="true"
    VALIDATE_ONLY="false"
    export DRY_RUN NON_INTERACTIVE FORCE_DEFAULTS VALIDATE_ONLY
    
    # Mock command availability - create a limited PATH with only docker
    mkdir -p "$TMPDIR/limited-bin"
    touch "$TMPDIR/limited-bin/docker"
    chmod +x "$TMPDIR/limited-bin/docker"
    
    # Add essential system commands that the function needs
    ln -s /usr/bin/sort "$TMPDIR/limited-bin/sort" 2>/dev/null || true
    ln -s /bin/echo "$TMPDIR/limited-bin/echo" 2>/dev/null || true
    ln -s /usr/bin/printf "$TMPDIR/limited-bin/printf" 2>/dev/null || true
    
    # Override PATH to simulate missing tools (except docker)
    export PATH="$TMPDIR/limited-bin:/bin:/usr/bin"
    
    # Mock functions that auto_install_deps calls
    log() { echo "LOG: $*"; }
    warn() { echo "WARN: $*"; }
    die() { echo "DIE: $*"; exit 1; }
    install_package() { echo "Installing: $1"; return 0; }
    export -f log warn die install_package
    
    run auto_install_deps
    [ "$status" -eq 0 ]
    # Should detect and attempt to install missing dependencies
    [[ "$output" == *"Installing:"* ]]
}
